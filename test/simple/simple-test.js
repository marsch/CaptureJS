require("../common");

var pcap = require('pcap');

var fixgen = require('fixgen'),
	suite;

var helper = {
	isType: function (val, type) {
		if(typeof val === "undefined" || val === null) {
			return false;
		}
		if(val.constructor && val.constructor.toString().indexOf(type) !== -1) {
			return true;
		}
		return false;
	}
}
		 
suite = vows.describe('Capturing packets');
suite.addBatch({
	'GIVEN a "fixgen" - constructor is called': {
		topic: function () {
			return fixgen();
		},
		'THEN it returns a value': function(topic) {
			assert.ok(typeof topic !== "undefined");
		},
		'THEN the returned value is a object': function(topic) {
			assert.ok(topic.constructor.toString().indexOf("Object") !== -1);
		},
		'AND the start-method is called': {
			topic: function (test) {
				this.NAME_OF_DEVICE = "en0";
				this.FILTER = "tcp";
				this.BUFFER_SIZE = 2048;
 
				this.capspy = sinon.spy(pcap, "createSession"); 

				this.trackerspy = sinon.spy(pcap.TCP_tracker.prototype, "on");

				this.pcapdecodespy = sinon.stub(pcap.decode, "packet");
				this.pcapsessionspy = sinon.spy(pcap.Pcap.prototype, "on");
				this.tracepacketspy = sinon.stub(pcap.TCP_tracker.prototype, "track_packet"); 
				
				
				this.SpyPcapOpen = sinon.spy(pcap.Pcap.prototype, "open");

				test.start(this.NAME_OF_DEVICE, this.FILTER, this.BUFFER_SIZE);

				//send some contents
				var sess = test.getPcapSession(); 
				sess.emit("packet", "DUMMY");
				return test;
			},
			'THEN the getStatus-method returns "capturing"': function (topic) {
				assert.equal(topic.getStatus(), "capturing");
			},
			'THEN the Pcap-Session is created by called CreateSession or CreateOfflineSession': function (topic) {
				assert.ok(this.capspy.called || this.capOfflineSpy.called, " createSession or createOfflineSession method is called");
				assert.ok(this.capspy.calledWith(this.NAME_OF_DEVICE, this.FILTER, this.BUFFER_SIZE), "createSession is called with the right params");
			},
			'the getDeviceName-Method': function (topic) {
				assert.ok((helper.isType(topic.getDeviceName, "Function")), "method exists");
				assert.ok((helper.isType(topic.getDeviceName(), "String")), "method returns a string");
			},
			'the TCPTracker registers to required handlers': function (topic) {
				assert.ok(this.trackerspy.calledWith('http request'), "http_request handler");
				assert.ok(this.trackerspy.calledWith('http request body'), "http_request_body handler");
				assert.ok(this.trackerspy.calledWith('http request complete'), "http_request_complete handler");
				assert.ok(this.trackerspy.calledWith('http response'), "http_response handler");
				assert.ok(this.trackerspy.calledWith('http response body'), "http_response_body handler");
				assert.ok(this.trackerspy.calledWith('http response complete'), "http_response_complete handler");
			},
			'the PCap Session registers to the packet handler': function (topic) {
				assert.ok(this.pcapsessionspy.calledWith('packet'), "registers to packet handler");
			},
			'pcap decodes the rawpacket': function (topic) {
				assert.ok(this.pcapdecodespy.called, "is called");
			},
			'redirect the decoded packet to tcptracer': function(topic) {
				assert.ok(this.tracepacketspy.called, "tracepacket is called");
			},
			'AFTER that the stop-method is called': {
				topic: function (topic) {
					this.SpyPcapClose = sinon.spy(pcap.Pcap.prototype, "close");
					topic.stop();
					return this;
				},
				'THEN the Pcap.prototype.close Method is internally called': function (topic) {
					assert.ok(this.SpyPcapClose.called);
				},
				teardown: function(test) {
					this.SpyPcapClose.restore();
				}
			},
			teardown: function(test) {
				this.capspy.restore();
				this.capOfflineSpy.restore();
				this.trackerspy.restore();
				this.pcapdecodespy.restore();
				this.pcapsessionspy.restore();
				this.tracepacketspy.restore();
				this.SpyPcapOpen.restore();
			//	test.stop();
			}
		}
	}
});

//handle if no network device is selected
//the device should be settable
//also the user should be able to apply filters
//there also should be an option to generate the fixtures with a autogenerated __validation (look if some thing is string, method is correct, status is correct, request is correct, some things must be left out, like dates, timestamps etc.)
//also there should be a replay option, to fire a collection of collected request packets and validate the responses out of nodejs and the browser - so validation must be switched to throws
exports.suite = suite;